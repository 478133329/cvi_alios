/*
 * Copyright (C) Cvitek Co., Ltd. 2019-2021. All rights reserved.
 *
 * File Name: isp_algo_ccm.c
 * Description:
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "isp_algo_ccm.h"
#include "isp_algo_debug.h"
#include "isp_algo_utility.h"

// Color temperature
#define COLOR_TEMP_MAX (30000)
#define COLOR_TEMP_MIN (500)

// Number of ISO values
#define NUM_ISO (16)

// Allowed ISO range
#define ISO_MAX (3276800)
#define ISO_MIN (100)
#define STEP_ISO (((ISO_MAX) - (ISO_MIN)) / (NUM_ISO - 1))

// General color temperature range
#define COLOR_TEMP_GENERAL_MAX (8000)
#define COLOR_TEMP_GENERAL_MIN (2500)

// Number of bits required for a decimal part of a CCM coeff
#define DECIMAL_BITS 10

// Number of CCM and its size
#define MATRIX_NUM (7)
#define MATRIX_SIZE (9)

static const float _RGB2Y[9] = { 0.299, 0.587, 0.114, -0.169, -0.331, 0.5, 0.5, -0.419, -0.081 };

static const float _Y2RGB[9] = { 1, -0.00093, 1.401687, 1, -0.3437, -0.71417, 1, 1.77216, 0.00099 };

static uint32_t g_Verbose;

//-----------------------------------------------------------------------------
//  basic functions
//-----------------------------------------------------------------------------
static void Mat_3x3_Product_3x3(float *A_3x3, const float *B_3x3, const float *C_3x3)
{
	for (uint8_t r = 0; r < 3; r++) {
		for (uint8_t c = 0; c < 3; c++) {
			float *A = &A_3x3[r * 3 + c];
			const float *B = &B_3x3[r * 3 + 0];
			const float *C = &C_3x3[0 * 3 + c];
			*A = 0;
			for (uint8_t i = 0; i < 3; i++) {
				*A += *B * *C;
				B++;
				C += 3;
			}
		}
	}
}

static void Mat_Print_3x3(char *header, float *A_3x3)
{
	printf("%s:\n", header);
	for (uint8_t r = 0; r < 3; r++) {
		printf("[");
		for (uint8_t c = 0; c < 3; c++) {
			float *A = &A_3x3[r * 3 + c];

			printf("%0.5f", *A);
			if (c != 3 - 1) {
				printf("\t");
			}
		}
		printf("]\n");
	}
	printf("\n");
}

static const unsigned int ISO_LUT[NUM_ISO] = {
	  100,   200,    400,    800,   1600,   3200,    6400,   12800,
	25600, 51200, 102400, 204800, 409600, 819200, 1638400, 3276800};

static int Interpolation(int Data[], int x);
static int Extrapolation(int Data[], int x);

static int CCM_MANUAL_API(ISP_CCM_MANUAL_ATTR_S *sManualCCM, uint8_t Saturation, uint16_t *uCCM_Result);
static int CCM_AUTO_API(ISP_CCM_AUTO_ATTR_S *sAutoCCM, ISP_SATURATION_AUTO_ATTR_S *sAutoSaturation,
	uint32_t ColorTemp, uint32_t IsoValue, uint16_t *uCCM_Result);

CVI_S32 isp_algo_ccm_main(struct ccm_param_in *ccm_param_in, struct ccm_param_out *ccm_param_out)
{
	// ISP_DEBUG(LOG_INFO, "%s\n", "+");
	CVI_S32 ret = CVI_SUCCESS;

	for (ISP_CHANNEL_LIST_E idx = ISP_CHANNEL_LE ; idx < ISP_CHANNEL_MAX_NUM ; idx++) {
		ISP_CCM_ATTR_S *ccm_Attr = (ISP_CCM_ATTR_S *) ISP_PTR_CAST_VOID(ccm_param_in->ccm_attr[idx]);
		ISP_SATURATION_ATTR_S *saturation_attr =
			(ISP_SATURATION_ATTR_S *) ISP_PTR_CAST_VOID(ccm_param_in->saturation_attr[idx]);
		if (ccm_Attr->enOpType == OP_TYPE_MANUAL) {
			CCM_MANUAL_API(&(ccm_Attr->stManual),
				saturation_attr->stManual.Saturation,
				ISP_PTR_CAST_U16(ccm_param_out->CCM[idx]));
		} else {
			CCM_AUTO_API(
				&(ccm_Attr->stAuto),
				&(saturation_attr->stAuto),
				ccm_param_in->color_temp[idx], ccm_param_in->iso,
				ISP_PTR_CAST_U16(ccm_param_out->CCM[idx]));
		}

	}

	return ret;
}

CVI_S32 isp_algo_ccm_init(void)
{
	// ISP_DEBUG(LOG_INFO, "%s\n", "+");
	CVI_S32 ret = CVI_SUCCESS;

	return ret;
}

CVI_S32 isp_algo_ccm_uninit(void)
{
	// ISP_DEBUG(LOG_INFO, "%s\n", "+");
	CVI_S32 ret = CVI_SUCCESS;

	return ret;
}

/**
 *  print 3x3 matrix for debugging
 *  @param header[in] a string to notify what the matrix is.
 *  @param M_3x3[in] a 3x3 matrix in type int16_t
 */
static void CCM_PrintMatrix(char *header, int16_t *M_3x3)
{
	printf("%s:\n", header);
	for (uint8_t r = 0; r < 3; r++) {
		printf("[");
		for (uint8_t c = 0; c < 3; c++) {
			int16_t *A = &M_3x3[r * 3 + c];

			printf("%d", *A);
			if (c != 3 - 1) {
				printf("\t");
			}
		}
		printf("]\n");
	}
	printf("\n");
}

/**
 *  calculate a 3x3 matrix satMat from saturation
 *  @param satMat[out] a 3x3 matrix that generated by saturation, unit gain is 1024.
 *  @param saturation[in] saturation in range[0,255]
 *  in general case, use CCM_GetSaturationMatrix() to create a saturation matrix that only dependent on saturation.
 *  For each frame, the ccm might changed since it is dependent on color temperature.
 *  So you need use CCM_GetSaturationMatrix() to combine saturation matrix and CCM matrix if color temperature changed.
 */
static void CCM_GetSaturationMatrix(int16_t *satMat, uint8_t saturation)
{
	if (g_Verbose) {
		printf("%s:\n", __func__);
	}

	float sat = saturation / 128.0;
	float S[9] = { 1, 0, 0, 0, sat, 0, 0, 0, sat };
	float t1[9] = { 0 };
	float t2[9] = { 0 };

	if (g_Verbose) {
		Mat_Print_3x3("Y sat mat:", S);
	}

	// Saturation Matrix = Y2RGB . S . RGB2Y
	Mat_3x3_Product_3x3(t1, S, _RGB2Y);
	Mat_3x3_Product_3x3(t2, _Y2RGB, t1);

	if (g_Verbose) {
		Mat_Print_3x3("RGB sat mat:", t2);
	}

	for (uint16_t i = 0; i < 9; i++) {
		int32_t v = ROUND(t2[i] * 1024.0);

		satMat[i] = LIMIT_RANGE(v, -8192, 8191);
	}

	if (g_Verbose) {
		CCM_PrintMatrix("int16 sat CCM:", satMat);
	}
}

/**
 *  let ccmWithSat = satMat . ccm
 *  @param ccmWithSat[out] a 3x3 matrix that combined ccm and satMat, unit gain is 1024.
 *  @param satMat[in] a 3x3 matrix, unit gain is 1024.
 *  @param ccm[in] a 3x3 matrix, unit gain is 1024.
 */
static void CCM_ApplySaturationMatrix(int16_t *ccmWithSat, int16_t *satMat, int16_t *ccm)
{
	float A_3x3[9] = {};

	// A = satMatrix * CCM = ccmWithSat in type float
	for (uint8_t r = 0; r < 3; r++) {
		for (uint8_t c = 0; c < 3; c++) {
			float *A = &A_3x3[r * 3 + c];
			int16_t *B = &satMat[r * 3 + 0];
			int16_t *C = &ccm[0 * 3 + c];
			*A = 0;
			for (uint8_t i = 0; i < 3; i++) {
				*A += *B * *C;
				B++;
				C += 3;
			}
		}
	}

	// convert A to ccmWithSat
	float *A = A_3x3;
	int16_t *B = ccmWithSat;

	for (uint8_t i = 0; i < 9; i++) {
		int32_t v = ROUND(*A / 1024.0);	//+-8219=2^14bit, 14 + 14 = 28 - 10 = 18
		*B = LIMIT_RANGE(v, -8192, 8191);
		A++;
		B++;
	}
}

/**
 *  @brief [Entry] Find the max absValue for each row of the 3*3 matrix index
 *  @param pCCM[in] A pointer to each row of the 3*3 matrix
 *  @return the max absValue index
 */
static int CCM_GetMaxAbsValueIdx(int16_t *pCCMRow)
{
	if (ABS(pCCMRow[0]) < ABS(pCCMRow[1])) {
		if (ABS(pCCMRow[1]) < ABS(pCCMRow[2])) {
			return 2;
		} else {
			return 1;
		}
	} else {
		if (ABS(pCCMRow[0]) < ABS(pCCMRow[2])) {
			return 2;
		} else {
			return 0;
		}
	}
}

/**
 *  @brief [Entry] Assure each row of CCM is normalized to unit
 *  @param pCCM[in] A pointer to a matrix
 */
static void CCM_Normalize(int16_t *pCCM)
{
	int rows = MATRIX_SIZE / 3;
	int cols = rows;

	for (int i = 0; i < rows; i++) {
		float fsum = 0;
		int isum = 0;

		for (int j = 0; j < cols; j++)
			fsum += (float)(pCCM[i * cols + j]);

		if (fsum <= 0) {
			memset(pCCM, (int16_t)0, sizeof(int16_t) * MATRIX_SIZE);
			pCCM[0] = pCCM[4] = pCCM[8] = 1024;
			break;
		}

		for (int j = 0; j < (cols - 0); j++) {
			pCCM[i * cols + j] =
				(int16_t)(pCCM[i * cols + j] / fsum * (1 << DECIMAL_BITS));
			isum += (int)pCCM[i * cols + j];
		}

		//Due to the problem of accuracy, after the above calculation,
		//it is still possible that the value is not equal to 1024.
		//To keep the RGB ratio as unchanged as possible,
		//we modify the parameter with the largest absolute value to
		//ensure that the sum of each row is equal to 1024
		if (isum != (1 << DECIMAL_BITS)) {
			int diff = (1 << DECIMAL_BITS) - isum;
			int maxAbsValueIdx = 0;

			maxAbsValueIdx = CCM_GetMaxAbsValueIdx(pCCM + (i * cols));
			pCCM[i * cols + maxAbsValueIdx] += diff;
		}
	}
}

static int CCM_MANUAL_API(ISP_CCM_MANUAL_ATTR_S *sManualCCM, uint8_t Saturation, uint16_t *uCCM_Result)
{
	if (sManualCCM->SatEnable == CVI_TRUE) {
		int16_t satMat[9] = {};

		CCM_GetSaturationMatrix(satMat, Saturation);
		CCM_ApplySaturationMatrix((int16_t *)uCCM_Result, satMat, sManualCCM->CCM);
	} else {
		memcpy(uCCM_Result, sManualCCM->CCM, sizeof(int16_t) * MATRIX_SIZE);
	}
	return 0;
}

static int CCM_AUTO_API(ISP_CCM_AUTO_ATTR_S *sAutoCCM, ISP_SATURATION_AUTO_ATTR_S *sAutoSaturation,
	uint32_t ColorTemp, uint32_t IsoValue, uint16_t *uCCM_Result)
{
	int i = 0;
	int16_t iCaliCCM[MATRIX_NUM][MATRIX_SIZE] = { 0 };
	int16_t IdentyMatrix[MATRIX_SIZE] = { (1 << DECIMAL_BITS), 0, 0, 0, (1 << DECIMAL_BITS), 0, 0, 0,
					      (1 << DECIMAL_BITS) };
	int16_t iCCM_Result[MATRIX_SIZE];
	int Data[4] = { 0 };
	int flag = 0;
//	int idx = 0;
	float ww = 0;
	// Forced to be in the valid range: [COLOR_TEMP_MIN, COLOR_TEMP_MAX]
	ColorTemp = (ColorTemp < COLOR_TEMP_MIN) ? COLOR_TEMP_MIN :
						   ((ColorTemp > COLOR_TEMP_MAX) ? COLOR_TEMP_MAX : ColorTemp);

	// DEBUG
	#if SIMULATION
	// printf("*******************************************\n");
	// printf("%s() input\n", __func__);
	// printf_auto_ccm(&sAutoCCM);
	// printf_auto_saturation(&sAutoSaturation);
	printf("ColorTemp=%d\t", ColorTemp);
	printf("IsoValue=%d\t", IsoValue);
	#endif

	//=============================================================================================================
	//  Convert hexadecimal format to decimat format
	//=============================================================================================================
	for (int i = 0; i < sAutoCCM->CCMTabNum; i++) {
		for (int j = 0; j < MATRIX_SIZE; j++) {
			if (((sAutoCCM->CCMTab[i].CCM[j] & 0x8000) >> 15) == 1)
				iCaliCCM[i][j] = (int16_t)sAutoCCM->CCMTab[i].CCM[j];
			else
				iCaliCCM[i][j] = sAutoCCM->CCMTab[i].CCM[j];
		}
	}

	//=============================================================================================================
	//  Calculate CCMs
	//=============================================================================================================
	for (i = 0; i < sAutoCCM->CCMTabNum; i++) {
		if (ColorTemp == sAutoCCM->CCMTab[i].ColorTemp) {
			memcpy(iCCM_Result, sAutoCCM->CCMTab[i].CCM, sizeof(uint16_t) * MATRIX_SIZE);
			flag = 1;
			break;
		}

		if (ColorTemp > sAutoCCM->CCMTab[i].ColorTemp) {
			if (i == 0) {
				Data[0] = sAutoCCM->CCMTab[i].ColorTemp;
				Data[1] = sAutoCCM->CCMTab[i + 1].ColorTemp;
				for (int j = 0; j < MATRIX_SIZE; j++) {
					Data[2] = iCaliCCM[i][j];
					Data[3] = iCaliCCM[i + 1][j];
					iCCM_Result[j] = Extrapolation(Data, ColorTemp);
				}
			} else {
				Data[0] = sAutoCCM->CCMTab[i - 1].ColorTemp;
				Data[1] = sAutoCCM->CCMTab[i].ColorTemp;

				for (int j = 0; j < MATRIX_SIZE; j++) {
					Data[2] = iCaliCCM[i - 1][j];
					Data[3] = iCaliCCM[i][j];
					iCCM_Result[j] = Interpolation(Data, ColorTemp);
				}
			}
			flag = 1;
			break;
		}
	}

	if (flag == 0) {
		Data[0] = (int)sAutoCCM->CCMTab[sAutoCCM->CCMTabNum - 1].ColorTemp;
		Data[1] = (int)sAutoCCM->CCMTab[sAutoCCM->CCMTabNum - 2].ColorTemp;
		for (int j = 0; j < MATRIX_SIZE; j++) {
			Data[2] = iCaliCCM[sAutoCCM->CCMTabNum - 1][j];
			Data[3] = iCaliCCM[sAutoCCM->CCMTabNum - 2][j];
			iCCM_Result[j] = Extrapolation(Data, ColorTemp);
		}
	}

	uint8_t saturation = 0;
	int16_t satMat[9] = {};

	if (IsoValue < ISO_LUT[0]) {
		IsoValue = ISO_LUT[0];
	} else if (IsoValue > ISO_LUT[NUM_ISO - 1]) {
		IsoValue = ISO_LUT[NUM_ISO - 1];
	} else {
		float d0 = 0, d1 = 1;

		for (int i = 0; i < NUM_ISO; i++) {
			if (ISO_LUT[i] == IsoValue) {
				saturation = sAutoSaturation->Saturation[i];

				break;
			}
			if (IsoValue < ISO_LUT[i]) {
				uint8_t saturation0 = sAutoSaturation->Saturation[i - 1];
				uint8_t saturation1 = sAutoSaturation->Saturation[i];

				d0 = IsoValue - ISO_LUT[i - 1];
				d1 = ISO_LUT[i] - IsoValue;

				saturation = (saturation0 * d1 + saturation1 * d0) / (d0 + d1);
				break;
			}
		}
	}

	CCM_GetSaturationMatrix(satMat, saturation);
	CCM_ApplySaturationMatrix((int16_t *)iCCM_Result, satMat, iCCM_Result);
	//=====================================================================
	//	ISOActEnable & TempActEnable
	//=====================================================================
	if (sAutoCCM->ISOActEnable == CVI_TRUE) {
		if (IsoValue > 12800) {
			float w = 12800 / MAX(IsoValue, 12800);

			for (uint8_t i = 0; i < 9; ++i) {
				iCCM_Result[i] *= w;
				iCCM_Result[i] += ((1 - w) * IdentyMatrix[i]);
			}
		}
	}

	//#define _debug
	if (sAutoCCM->TempActEnable == CVI_TRUE) {
		if ((ColorTemp >= COLOR_TEMP_GENERAL_MIN) && (ColorTemp <= COLOR_TEMP_GENERAL_MAX)) {
			// Do nothing
		} else {
			if (ColorTemp > COLOR_TEMP_GENERAL_MAX) {
				ww = MAX(1.0 - (float)(ColorTemp - COLOR_TEMP_GENERAL_MAX)
					/ (COLOR_TEMP_MAX - COLOR_TEMP_GENERAL_MAX), 0);

			} else if (ColorTemp < COLOR_TEMP_GENERAL_MIN) {
				ww = MAX(1.0 - (float)(COLOR_TEMP_GENERAL_MIN - ColorTemp)
					/ (COLOR_TEMP_GENERAL_MIN - COLOR_TEMP_MIN), 0);
			}

			uint8_t saturation = LIMIT_RANGE(ww * 128 + 0.5, 0, 255);
			int16_t satMat[9] = {};

			CCM_GetSaturationMatrix(satMat, saturation);
			CCM_ApplySaturationMatrix((int16_t *)iCCM_Result, satMat, iCCM_Result);
		}
	}

	//=====================================================================
	//	Assure each row of CCM is normalized to unit
	//=====================================================================
	CCM_Normalize(iCCM_Result);

	#if SIMULATION
	for (int i = 0; i < rows; i++) {
		for (int j = 0; j < (cols - 0); j++) {
			printf("%d\t", iCCM_Result[i * cols + j]);
		}
	}
	printf("\n");
	#endif

	memcpy(uCCM_Result, iCCM_Result, sizeof(uint16_t) * MATRIX_SIZE);

	return 0;
}

/**
 * @brief Interpolation
 *
 * @param[out] CCM_Result Output CCM of 9 coefficients
 * @param[in]  ColorTemp  Color temperature
 * @param[in]  sAutoCCM   CCM (auto mode)
 */
static int Interpolation(int Data[], int x)
{
	int range = (Data[0] - Data[1]);
	int d0 = Data[0] - x;
	int d1 = x - Data[1];

	return ((Data[2] * d1 + Data[3] * d0) / range);
}

/**
 * @brief Linear Extrapolation
 *
 * @param[out] CCM_Result Output CCM of 9 coefficients
 * @param[in]  ColorTemp  Color temperature
 * @param[in]  sAutoCCM   CCM (auto mode)
 */
static int Extrapolation(int Data[], int x)
{
	int range = (Data[0] - Data[1]);

	if (range == 0)
		return Data[0];

	return ((Data[2] * range + (x - Data[0]) * (Data[2] - Data[3])) / range);
}
